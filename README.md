# ğŸ“ README â€“ Auto-Generated Blog (React + Node.js + PostgreSQL + Docker + AWS)

## ğŸ“Œ Project Overview

This project is a fully automated blog system that generates, stores, and displays articles generated by a inference model in Hugging face.
It includes:

- React frontend (blog UI)
- Node.js backend (REST API + AI article generator + cron scheduler)
- PostgreSQL database for persistent storage
- Daily automatic article generation powered by the Hugging Face Inference API
- Dockerized full-stack application
- AWS CI/CD pipeline using CodePipeline, CodeBuild, ECR, and EC2
- The goal is to build a simple yet production-ready system

## ğŸ—ï¸ System Architecture

User â†” React (Frontend)
          â†“
     Node.js API
          â†“
   PostgreSQL Database
          â†“â†‘
AI Generation (HuggingFace API)
          â†“
Automatic Daily Cron Job (node-cron)

CI/CD Pipeline:
GitHub â†’ CodePipeline â†’ CodeBuild â†’ ECR â†’ EC2 (Docker)

## âœ¨ Application Features
### âœ… Auto-Generated Articles

The backend uses the Hugging Face Inference API to generate new articles.
Each article contains:

- Title

- Body content

- Timestamp

- Unique ID

- Summary

You can configure topics by sending it to the endpoint

### âœ… Daily Article Generation (Automation)

A node-cron scheduled job runs once per day at 2 am

### âœ… Full CRUD API (Minimal for the challenge)

GET /articles â†’ list all articles

GET /articles/:id â†’ Get a single article

POST /articles/generateArticle â†’ Create a custom article by sending it the data (title, content, summary)

POST /articles/generateAIArticle â†’ Create a IA generated article by sending it the data, the title can be send as "title" in the body of the request

### âœ… Frontend (React)

List of all articles

Article detail page

Clean and minimal blog UI

Uses a small internal API client for backend communication

## ğŸ§  AI Integration Details

The project uses Hugging Face Inference API (free tier) with a lightweight text-generation model "Qwen/Qwen2.5-7B-Instruct"

## ğŸ—„ï¸ Database (PostgreSQL)

Table structure:

articles (
  id SERIAL PRIMARY KEY,
  title TEXT,
  content TEXT,
  summary TEXT,
  created_at TIMESTAMP DEFAULT now()
);

## ğŸ³ Docker Architecture

Both frontend and backend include their own Dockerfiles:

/frontend/Dockerfile
/backend/Dockerfile


Local development uses:

docker-compose.yml


that starts:

react-app

backend-api

postgres-db

## ğŸŒ Deployment on AWS
AWS Components Used

EC2: hosts the production containers

ECR: stores Docker images

CodeBuild: builds Docker images from repo

CodePipeline: automates CI/CD process

SSM + shell script: updates containers on EC2 instance

Security Groups: allow web access & ECR pulls

Deployment Flow
1. Developer pushes code â†’ GitHub
3. CodeBuild triggers:
      - builds Docker images
      - pushes them to ECR
      - sends the instruction to SSM to initiate the EC2 script that:
4. EC2:
      - stops existing containers
      - pulls latest images
      - starts updated backend + frontend

## ğŸ§ª Running Locally
1. Clone the repo
git clone 
cd project/infra

2. Run with Docker Compose
docker-compose up --build

3. Access the app
Frontend: http://localhost:3000
Backend:  http://localhost:4000

## ğŸš¢ Deployment Script (EC2)

There is also an example in infra of the script used in EC2 to pull and up the docker images in EC2, obviously, adapted to work in local work

## ğŸš€ Future Improvements

If given more time, I would add:

- Authentication & admin panel
- Rich text formatting
- Tags & categories
- Dedicated model in AWS for text generation
- Integration of a model for Image generation for posts
- Monitoring (CloudWatch logs, alarms)
- CI/CD rollback triggers
- Unit testing
- Open API + Swagger Docs